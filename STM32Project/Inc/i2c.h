/**
  ******************************************************************************
  * File Name          : I2C.h
  * Description        : This file provides code for the configuration
  *                      of the I2C instances.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */
/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __i2c_H
#define __i2c_H
#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* USER CODE BEGIN Private defines */
#define MAXWAIT (50)
/* USER CODE END Private defines */

void MX_I2C1_Init(void);

/* USER CODE BEGIN Prototypes */


static inline uint8_t waitRXNE(I2C_TypeDef *I2Cx, uint32_t maxWait) {
	uint32_t cnt = 0;
	while(!LL_I2C_IsActiveFlag_RXNE(I2Cx) && cnt < maxWait) {
		++cnt;
	}
	return cnt < maxWait;
}


//send one byte to the slave_addr, register_addr
//function is blocking, until communiaction done
static inline uint8_t i2c_write(uint8_t slave_addr, uint8_t register_addr, uint8_t data) {

	//fcn send START, sends the SLAVE address
	LL_I2C_HandleTransfer(I2C1, slave_addr, LL_I2C_ADDRSLAVE_7BIT, 2, LL_I2C_MODE_AUTOEND, LL_I2C_GENERATE_START_WRITE);

	//next we send the register address we want to write to
	LL_I2C_TransmitData8(I2C1, register_addr);

	//STOP is generated by the hardware after all data has been sent and acknowledged
	uint32_t cnt = 0;
	while(!LL_I2C_IsActiveFlag_STOP(I2C1))
	{
		++cnt;
		if(cnt > MAXWAIT) {
			return 0;
		}
		if(LL_I2C_IsActiveFlag_TXIS(I2C1))	//flag is SET when transmit register is empty
		{
			LL_I2C_TransmitData8(I2C1, data);
		}
	}
	LL_I2C_ClearFlag_STOP(I2C1);	//clear the stop flag, end of communication

	return 1;
}


//receives n bytes from the given address and register
//block, until n data is received
static inline uint8_t i2c_read_n(uint8_t slave_addr, uint8_t register_addr, uint8_t* buffer, uint8_t length) {

	//send START, sends the SLAVE address
	LL_I2C_HandleTransfer(I2C1, slave_addr, LL_I2C_ADDRSLAVE_7BIT, 1, LL_I2C_MODE_AUTOEND, LL_I2C_GENERATE_START_WRITE);

	//send register address which will be read
	uint32_t cnt = 0;
	while(!LL_I2C_IsActiveFlag_STOP(I2C1))
	{
		++cnt;
		if(cnt > MAXWAIT) {
			return 0;
		}
		if(LL_I2C_IsActiveFlag_TXIS(I2C1))
		{
			LL_I2C_TransmitData8(I2C1, register_addr);
		}
	}
	LL_I2C_ClearFlag_STOP(I2C1);
	while(LL_I2C_IsActiveFlag_STOP(I2C1)){}
	//end of first half


	//send START and address, also set read bit
	LL_I2C_HandleTransfer(I2C1, slave_addr, LL_I2C_ADDRSLAVE_7BIT, length, LL_I2C_MODE_AUTOEND, LL_I2C_GENERATE_START_READ);

	//keep reading, until length data has been read
	while(length) {
		if(!waitRXNE(I2C1, MAXWAIT)) return 0;	//wait until for RXNE to go to true
		*buffer = LL_I2C_ReceiveData8(I2C1);	//read the data
		++buffer;	//buffer now points to next place in the buffer
		--length;
	}

	cnt = 0;
	while(!LL_I2C_IsActiveFlag_STOP(I2C1)){
		++cnt;
		if(cnt > MAXWAIT) {
			I2C1->ICR |= (1 << 4);	//clear NACK flag
			return 0;
		}
	};

	//End of transfer
	LL_I2C_ClearFlag_STOP(I2C1);

	return 1;
}


//optimized funtion to directly read the mpu registers into int16 values, automatically converets endian
static inline uint8_t i2c_read_n_int16(uint8_t slave_addr, uint8_t register_addr, int16_t* buffer, uint8_t n) {

	uint8_t* buff = (uint8_t*) buffer;		//to be able to read byte-by-byte

	//send START, sends the SLAVE address
	LL_I2C_HandleTransfer(I2C1, slave_addr, LL_I2C_ADDRSLAVE_7BIT, 1, LL_I2C_MODE_AUTOEND, LL_I2C_GENERATE_START_WRITE);

	//send register address which will be read
	uint32_t cnt = 0;
	while(!LL_I2C_IsActiveFlag_STOP(I2C1))
	{
		++cnt;
		if(cnt > MAXWAIT) {
			return 0;
		}
		if(LL_I2C_IsActiveFlag_TXIS(I2C1))
		{
			LL_I2C_TransmitData8(I2C1, register_addr);
		}
	}
	LL_I2C_ClearFlag_STOP(I2C1);
	while(LL_I2C_IsActiveFlag_STOP(I2C1)){}
	//end of first half


	//send START and address, also set read bit
	LL_I2C_HandleTransfer(I2C1, slave_addr, LL_I2C_ADDRSLAVE_7BIT, 6, LL_I2C_MODE_AUTOEND, LL_I2C_GENERATE_START_READ);

	uint8_t ind = 1;
	for(uint8_t i = 0; i < n; ++i) {
		if(!waitRXNE(I2C1, MAXWAIT)) return 0;	//wait until for RXNE to go to true
		buff[ind] = LL_I2C_ReceiveData8(I2C1);
		if(!waitRXNE(I2C1, MAXWAIT)) return 0;	//wait until for RXNE to go to true
		buff[ind - 1] = LL_I2C_ReceiveData8(I2C1);

		ind += 2;
	}

	cnt = 0;
	while(!LL_I2C_IsActiveFlag_STOP(I2C1)){
		++cnt;
		if(cnt > MAXWAIT) {
			I2C1->ICR |= (1 << 4);	//clear NACK flag
			return 0;
		}
	};

	//End of transfer
	LL_I2C_ClearFlag_STOP(I2C1);
	I2C1->ICR |= (1 << 4);	//clear NACK flag

	return 1;
}


/* USER CODE END Prototypes */

#ifdef __cplusplus
}
#endif
#endif /*__ i2c_H */

/**
  * @}
  */

/**
  * @}
  */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
